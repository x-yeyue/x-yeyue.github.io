---
title: 数论
date: 2026-02-20 17:29:01
tags:
katex: true
sticky: 100
hide: false
---

# 数论

## 定理

### 算数基本定理(唯一分解定理)

> **算数基本定理**($fundamental ~ theorem ~ of ~ arithmetic$, 又称**唯一分解定理**，$unique ~ factorization ~ theorem$) —— 任意**合数** $c$ 可以表示成有限个素数 $p_{i}$ 的乘积，而且在不考虑素数乘积顺序的情况下其表示方式唯一。
> $$c = p_{1}^{e_{1}} p_{2}^{e_{2}} \cdots p_{n}^{e_{n}}$$
> **引理：** 对任意大于 $1$ 的正整数 $n$ ，$n$ 至多有一个大于 $\sqrt{n}$ 的质数。假设该质数存在，它的唯一分解式子中的质数一定为 $1$ 。

### 费马小定理

> **费马小定理**($Fermat's ~ little ~ theorem$)指出：给定任意**素数** $p$，对于**整数** $a$,如果 $1 \lt a \lt p$，有以下结论：
> $$a^{p-1} \equiv 1 \pmod{p}$$

### 裴蜀定理

> 如果 $a$ 和 $b$ 是不全为 $0$ 的整数，则有整数 $x$、$y$，使得 $ax + by = \gcd\left(a, b\right)$。

**推论**：

1. 如果 $a$ 和 $b$ 是不全为 $0$ 的整数，且 $a$ 和 $b$ 互质，当且仅当存在整数 $x$、$y$，使得 $ax+by=1$ 。
    - 若 $ax+by=1$，则 $a$ 和 $b$ 互质。
2. 如果 $a$ 和 $b$ 是不全为 $0$ 的整数，并且 $ax + by = c$ 有整数解解，那么 $c$ 一定是 $\gcd\left(a,b\right)$ 的整数倍。
    - 若 $c$ 不是 $\gcd\left(a,b\right)$ 的整数倍，那么 $ax + by = c$ 就没有整数解。
3. $a$ 和 $b$ 两项的裴蜀定理，可以推广到多项的情况。
    - 例如: $ax + by + cz + dp=\gcd\left(a,b,c,d\right) = s$

**注**：如果 $ax + by = c$一旦有解，就意味着一定有无穷多组 $\left(x, y\right)$，都可以使得式子成立。

### 整除性

> 如果 $a$ 和 $b$ 为整数且 $a \neq 0$，$a$ 整除($divides$) $b$ 是指存在整数 $c$ 使得 $b = ac$，如果 $a$ 整除 $b$，称 $a$ 是 $b$ 的一个因子，且称 $b$ 是 $a$ 的倍数，将其记为 $a \mid b$，如果 $a$ 不能整除 $b$，则将其记为 $a \nmid b$。

## 素数

> 对于整数 $a \gt 1$，如果它只能被 $1$ 和自身整除，则称 $a$ 为**素数**（$prime ~ number$，或称**质数**）。
> 对于大于 $1$ 的整数 $a$ 来说，如果 $a$ 不是素数，则称 $a$ 为**合数**（$composite ~ number$）。  
    > 合数可以表示成素数的乘积，如果不考虑乘积的顺序，其表示方式是唯一的，此即算数基本定理。  

### 素数判定

> 可以通过**筛法**将所有的素数都筛选出来，后直接判断。也可以朴素的判断。

朴素判断

```c++
bool isPrime(int a){
    if(a <= 1) return false;
    if(a == 2) return true;
    if(!(a & 1)) return false;
    int fac = (int)sqrt(a);
    for(int i = 3; i <= fac; i += 2){
        if(a % i == 0) return false;
    }
    return true;
}
```

### 筛法

> 判断一个区间内有哪些质数。

#### 朴素筛

```c++
bool judge[maxn]; // 是否是非质数 true:非质数
int prime[maxn], cnt = 0; // 存储发现的质数,质数的数量
int getPrimes(int n){
    for(int i = 2; i <= n; i ++){
        if(!judge[i]){
            prime[cnt ++] = i;
        }
        for(int j = i * i; j <= n; j += i){ // 将其的倍数标记非质数
            judge[j] = true;
        }
    }
    return cnt;
}
```

#### 埃式筛

```c++
bool judge[maxn]; // 是否是非质数 true:非质数
int prime[maxn], cnt = 0; // 存储发现的质数,质数的数量
int getPrimes(int n){
    for(int i = 2; i <= n; i ++){
        if(!judge[i]){
            prime[cnt ++] = i;
            for(int j = i * i; j <= n; j += i){ // 将其的倍数标记非质数，仅循环质数
                judge[j] = true;
            }
        }
    }
    return cnt;
}
```

#### 线性筛

> 时间复杂度：$O(n)$

```c++
bool judge[maxn];
int prime[maxn], cnt = 0;
int getPrimes(int n){
    for(int i = 2; i <= n; i ++){
        if(!judge[i]){
            prime[cnt ++] = i;
        }
        for(int j = 0; prime[j] * i <= n; j ++){
            judge[prime[j] * i] = true;
            if(i % prime[j] == 0){
                break;
            }
        }
    }
    return cnt;
}
```

### 素因子分解

> 根据**算数基本定理**，任意合数都可以表示为素数的乘积形式，即给定合数 $c$，可以将其表示为以下形式。
> $$c = p_{1}^{e_{1}} p_{2}^{e_{2}} \cdots p_{n}^{e_{n}}$$

在生成素数序列后(通过筛法获取)，假设序列中最大的素数为 $p_{max}$，利用已有的素数，可以很容易得将小于等于 $p_{max} \times p_{max}$ 的数进行因式分解。

```c++
unordered_map<int, int> get_prime_fac(int x){
	unordered_map<int, int> factors; // 记录每个素因子出现的次数
	for(int i = 0; i < cnt; i ++){ // cnt 表示通过筛法筛出的素数的个数
	    if(prime[i] * prime[i] > x) break;
	    while(x % prime[i] == 0){
	        x /= prime[i];
	        factors[prime[i]] ++;
	    }
	}
}

unordered_map<int, int> get_prime_fac(int x){
    unordered_map<int, int> fac;
    if(x == 0){
        return fac;
    }
    fac[1] = 1;
    for(int i = 2; i * i <= x; i ++){
        if(x % i != 0) continue;
        while(x % i == 0){
            fac[i] ++;
            x /= i;
        }
    }
    if(x > 1) fac[x] ++;
    return fac;
}
```


**合数 $c$ 总共有多少个不同的约数?**
> 设 $\tau(c)$ 表示合数 $c$ 不同约数的个数，$e_{i}$ 表示合数 $c$ 的第 $i$ 项素因子的个数。可证明：
> $$\tau\left(c\right) = \prod_{i=1}^{k}\left(e_{i} + 1\right) = \left(e_{1} + 1\right)\left(e_{2} + 1\right) \cdots \left(e_{k} + 1\right)$$
> 类似地，设 $\sigma\left(c\right)$ 表示合数 $c$ 的所有不同约数的和，$p_{i}$表示合数 $c$ 的第 $i$ 项素因子，$e_{i}$表示合数 $c$ 的第 $i$ 项素因子的个数。可证明：
> $$\sigma\left(c\right) = \prod_{i=1}^{k}\frac{p_{i}^{e_{i}+1}-1}{p_{i}-1} = \frac{p_{1}^{e_{1}+1}-1}{p_{1}-1} \times \frac{p_{2}^{e_{2}+1}-1}{p_{2}-1} \times \cdots \times \frac{p_{k-1}^{e_{k-1}+1}-1}{p_{k-1}-1} \times \frac{p_{k}^{e_{k}+1}-1}{p_{k}-1}$$

可以根据素因子分解的结果进一步得到这些不同的约数。

```c++
vector<int> divisors = {1};     // 约数
for(auto &[fac, cnt] : factors){    // fac:素因子   cnt:素因子的个数
    int base = 1, countOfDivisors = divisors.size();    // 基数，当前约数的数量
    for(int i = 1; i <= cnt; i ++){
        base *= fac;    // 更新基数
        for(int j = 0; j < countOfDivisors;j ++){
            divisors.emplace_back(divisors[j] * base);
        }
    }
}
// 排序并去重
sort(divisors.begin(), divisors.end()); 
divisors.erase(unique(divisors.begin(), divisors.end()), divisors.end());
```


## gcd 与 lcm

### 最大公约数(gcd)

> - **定义:** 对于不全为 0 的整数 $a$, $b$, 它们的最大公约数是 *最大的正整数* *d*, 使得 $d \mid a$ 且 $d \mid b$, 记作 $\gcd(a, b)$。
> - **约定:** $\gcd(a, 0) = |a|$ 

#### 欧几里得算法（辗转相除法）
<div>
$$
\gcd(a, b) = 
\begin{cases} a, & b = 0 \\ 
    \gcd \left(b, a \bmod b\right), & b \neq 0
\end{cases}
$$
</div>

```c++
int gcd(int a, int b){
    if(a < b) swap(a, b);
    return b ? gcd(b, a % b) : a;
}
```

也可以使用头文件 `<algorithm>` 中的内齿求最大公因数的函数`__gcd(a, b)`。

### 最小公倍数(lcm)

> **定义:** 对于正整数 $s, b$， 它们的最小公倍数是 *最小的正整数* $m$，使得 $a \mid m$ 且 $b \mid m$，记作 $lcm(a, b)$。

### 常用结论

对于正整数 $a, b$，有:
$$\gcd(a, b) \times lcm(a, b) = a \times b$$

根据 [唯一分解定理](#算数基本定理(唯一分解定理)):
$$a = \prod p_{i}^{e_{i}}, ~ ~ b = \prod p_{i}^{f_{i}}$$
则:
1. *gcd*: 取每个质因子的 *最小* 指数。
   $$\gcd(a, b) = \prod p_{i}^{\min(e_{i}, f_{i})}$$
2. *lcm*: 取每个质因子的 *最大* 指数。
   $$lcm(a, b) = \prod p_{i}^{\max(e_{i}, f_{i})}$$
### 互质

> 如果正数 $a$ 和 $b$ 的最大公因数为 $1$，则称 $a$ 和 $b$ **互素($relative ~ prime$，或称互质)**。

- 显然两个素数的最大公约数为 $1$，有时两个非质数的最大公约数也可能为 $1$，如 $4$ 和 $9$。
- 大于 $1$ 的两个质数总是互质的。

**互质的性质**
设 $a \lt b$，则 $ka\left(1 \leq k \leq b\right)$ 除以 $b$ 的余数会取遍 $0 \sim b-1$ 且不会发生重复。
例如： $5$ 和 $7$ 互为质数，则 $5k(1 \leq k \leq 7)$ 除以 $7$ 的余数依次为 $5$、$3$、$1$、$6$、$4$、$2$、$0$，取遍了 $0 \sim 6$ 的余数值。

## 扩展欧几里得算法

给出以下式子，求解一组整数数 $x$ 和 $y$;
$$ax + by = c \left(a, b, c \in \mathbb{Z} \right)$$

根据**裴蜀定理**可以构造以下方程，且$\gcd\left(a, b\right) \mid c$。
$$ax + by = \gcd\left(a, b\right)$$

令 $a' = b$， $b' = a ~ mod ~ b$，有
$$a'x' + b'y' = \gcd\left(a', b'\right) = gcd\left(b, a ~ mod ~ b\right)$$

结合欧几里得算法中的等式
$$\gcd\left(a, b\right) = \gcd\left(b, a ~ mod ~ b\right)$$

可得到：
<div>
$$
\begin{split}
ax + by &= a'x' + b'y' \\
        &= bx' + \left(a ~ mod ~ b\right)y' \\
        &= bx' + \left(a - \left\lfloor\frac{a}{b}\right\rfloor \cdot b\right)y' \\
        &= bx' + ay' - \left\lfloor\frac{a}{b}\right\rfloor \cdot b \cdot y'
\end{split}
$$
</div>

整理可得
$$ax + by = ay' + b \left(x' - \left\lfloor\frac{a}{b}\right\rfloor \cdot y'\right)$$

故可得到
<div>
$$
\begin{cases}
x = y' \\
y = x' - \left\lfloor\frac{a}{b}\right\rfloor \cdot y'
\end{cases}
$$
</div>

不断运用欧几里得算法进行计算，直到 $\gcd\left(a', b'\right)$ 中 $b' = 0$，此时 $\gcd\left(a', 0\right) = a'$，故带入 $a'x' + b'y' = \gcd\left(a', b'\right)$ 可以得到 $x' = 1$，此时 $y'$ 可以取任意数，一般取 $y' = 0$。
即当 $b' = 0$ 时
<div>
$$
\begin{cases}
x' = 1 \\
y' = 0
\end{cases}
$$  
</div>

通过不断地往回带入即可得最终解。

```c++
'''
注：求出的是 ax + by = gcd(a, b) 的 x 和 y 非 ax + by = c;
    因 gcd(a, b) | c 记得进行进行放缩。
'''
void extgcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return;
    }
    extgcd(b, a % b, x, y);
    int t = x - a / b * y;
    x = y, y = t;
}
```

对于不定方程 $ax + by = \gcd\left(a, b\right)$，扩展欧几里得算法求得的特解为 $\left(x', y'\right)$。其**通解**可表示为：
$$x = x' + \left\lfloor\frac{b}{\gcd\left(a, b\right)}\right\rfloor \cdot k,~ y = y' - \left\lfloor\frac{a}{\gcd\left(a, b\right)}\right\rfloor \cdot k ,~ k \in \mathbb{Z}$$

## 线性同余方程

> 称形式类似于
$$ax \equiv c \pmod{b}\left(a, b, c, x \in \mathbb{Z} \right)$$
>
>的方程为**线性同余方程**(又称一次同余方程，因为在同余方程中，未知数的幂仅为一次)。

显然当 $a = 0$ 时，只有 $c = 0$ 时，该线性同余方程才有解，此时任意整数 $x$ 均为其解。
若 $a \neq 0$，则可将其转换为二元一次不定方程，进而使用*扩展欧几里得算法*解决。求解该同余方程等价于求解
$$ax + by = c \left(a, b, c, x, y \in \mathbb{Z} \right)$$

根据*裴蜀定理*，只有当 $\gcd\left(a, b\right) \mid c$ 时，该不定方程才有解，且有 $\gcd\left(a, b\right)$ 个不同解。由*扩展欧几里得算法*求出不定方程的一个基本解 $x_{0}$ 后，则同余方程的所有模 $b$ 且互不同余的基本解 $x$ 可以表示为
$$x = x_{0} + \left\lfloor\frac{b}{\gcd\left(a, b\right)}\right\rfloor \cdot t, ~ t = 0, 1, \cdots, d-1$$

---

## 模算术

$a \bmod b = c$ 即 $a = b \cdot k + c,(k \in Z)$

特别的，如果数 $a$ 和数 $b$ 关于 $m$ 的模相等，记作 $a \equiv b \pmod{m}$

### 可乐兑换

> 给定 n 瓶可乐，将可乐喝完后会产生 n 个空瓶，若假定 m 个空瓶可以兑换一瓶新的可乐（可以向收货商再“借”若干空瓶，但需要归还同等数量的空瓶），确定能够兑换的总的可乐瓶数。注意，新兑换的可乐在喝完后会产生新的空瓶，这些空瓶也可以继续用来兑换可乐。
> 按照上述假设，则共能够喝到的可乐瓶数为 $$T = n + \left\lfloor\frac{n}{m - 1}\right\rfloor = \left\lfloor\frac{nm}{m - 1}\right\rfloor$$  

理解上述结果的关键是认识到 $(m - 1)$ 个空瓶等价于一瓶可乐，即使用 $(m - 1)$ 个空瓶，再向商家“借一个空瓶”，凑成 $m$ 个空瓶，兑换得到一瓶可乐，将可乐喝完会产生一个空瓶，将此空瓶还给商家即可。

公式 $T = n + \left\lfloor \frac{n}{m-1} \right\rfloor = \left\lfloor \frac{nm}{m-1} \right\rfloor$，可以通过数论中的代数变形和取整函数性质来推导。以下是详细证明过程：  

1. **分解分子项**  
   将右侧表达式的分子 $nm$ 拆分为 $n(m-1) + n$，则：  
   $$\frac{nm}{m-1} = \frac{n(m-1) + n}{m-1} = n + \frac{n}{m-1}$$  
   因此右侧公式可改写为：  
   $$\left\lfloor \frac{nm}{m-1} \right\rfloor = \left\lfloor n + \frac{n}{m-1} \right\rfloor$$  

2. **利用取整函数的线性性质**  
   对于任意整数 $n$ 和实数 $x$，有：  
   $$\left\lfloor n + x \right\rfloor = n + \left\lfloor x \right\rfloor$$  
   此处 $x = \frac{n}{m-1}$，代入后得：  
   $$\left\lfloor n + \frac{n}{m-1} \right\rfloor = n + \left\lfloor \frac{n}{m-1} \right\rfloor$$  
   这正是左侧的表达式 $T$，故等式成立。  

### 模运算规则

**加法规则** : $(x + y) \bmod n = ((x \bmod n) + (y \bmod n)) \bmod n$  

**减法规则** : $(x - y) \bmod n = ((x \bmod n) - (y \bmod n)) \bmod n$  

**乘法规则** : $xy \bmod n = (x \bmod n)(y \bmod n) \bmod n$

**乘方规则** : $x ^ y \bmod n = (x \bmod n)^y \bmod n$

#### 结论

- 判断一个数是否能被 $3$ 整除，只需要验证该整数各位数相加之和能否被 $3$整除即可。

根据模运算规则，有同余式 $10 \equiv 1 \pmod{3}$成立，因此有$10^k \equiv 1 \pmod{3}$成立，则有：
<div>
$$
\begin{split}
    (a_{k}a_{k-1} \cdots a_{2} a_{1} a_{0})_{10}&= a_{k}10^{k} + a_{k-1}k^{k-1} + \cdots + a_{1}10 + a_{0} \\
    &\equiv a_{k} + a_{k-1} + \cdots + a_{1} + a_{0} \pmod{3}
\end{split}
$$
</div>

- 同样的，检验一个整数能否被 $9$ 整除，只需要检验该整数各位数相加之和能否被 $9$ 整除即可。

由于 $10 \equiv 1 \pmod{9}$ 成立，因此有 $10^k \equiv 1 \pmod{9}$ 成立,则有
<div>
$$
\begin{split}
    (a_{k}a_{k-1} \cdots a_{2} a_{1} a_{0})_{10}&= a_{k}10^{k} + a_{k-1}k^{k-1} + \cdots + a_{1}10 + a_{0} \\
    &\equiv a_{k} + a_{k-1} + \cdots + a_{1} + a_{0} \pmod{9}
\end{split}
$$
</div>

- 类似的因为 $10 \equiv -1 \pmod{11}$，有

<div>
$$
\begin{split}
    (a_{k}a_{k-1} \cdots a_{2}a_{1}a_{0})_{10} &= a_{k}10^{k}+a_{k-1}10^{k-1}+ \cdots + a_{1}10+a_{0} \\
    &\equiv a_{k}\left(-1\right)^{k} + a_{k-1}\left(-1\right)^{k-1}+ \cdots +a_{2} - a_{1} + a_{0} \pmod{11}
\end{split}
$$
</div>
这表明$(a_{k}a_{k-1} \cdots a_{2}a_{1}a_{0})_{10}$ 能被 $11$ 整除的充要条件是对 $n$ 的各位数字交替相加减，所得到的整数 $a_{0}-a_{1}+a_{2}-\cdots+\left(-1\right)^{k}a^{k}$能被 $11$ 整除。

### 模的逆元

> **定义：**
> 若存在正整数 $a$、$b$、$m$，满足 $a \times b \equiv 1 \pmod{m}$，则称 $b$ 为 $a$ 在模 $m$ 下的逆元，一般记作 $a^{-1} \equiv b \pmod{m}$。
> 
> **性质：**
> - **逆元是"相互"的:** 如果 $b$ 是 $a$ 的逆元，那么 $a$ 也是 $b$ 的逆元，即 $b^{-1} \equiv a \pmod{m}$
> - **把除法变乘法:** 若 $a \times b \equiv 1 \pmod{m}$，即 $b$ 为 $a$ 在模 $m$ 下的逆元，则 $x \div a \pmod{m}$ 等价于 $x \times b \pmod{m}$。

#### 费马小定理法

根据费马小定理，对于任意素数 $p$，如果整数 $a$ 满足 $1 \lt a \lt p$，有
$$a^{-1} \equiv 1 \pmod{p}$$

根据上述结论，有 $a^{p-1} \equiv a \times a^{p-2} \equiv 1 \pmod{p}$，则 $a$ 的逆元为 $a^{p-2}$。
**注：$p$需是素数。**

#### 扩展欧几里得法

给定模数 $p$，求 $a$ 模 $p$ 的逆元相当于求解 $ax \equiv 1\pmod{p}$，该线性同余方程可转为求解不定方程 $ax + ny = 1$，可利用扩展欧几里得算法求解，并**将求解出的 $x_0$ 调整到区间$\left[0, n - 1\right]$ 即为所求逆元。
若 $\gcd\left(a, n\right) \neq 1$，则 $a$ 模 $n$ 的逆元不存在。

```c++
void extgcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return;
    }
    extgcd(b, a % b, x, y);
    int t = x - a / b * y;
    x = y, y = t;
}

int get_inv(int a, int p){
    // ax = 1 (mod p)
    if(gcd(a, p) != 1){
        return -1; // 无逆元
    }
    int x, y;
    extgcd(a, p, x, y);
    if(x < 0){
        x = (x % p + p) % p;
    }
    return x % p;
}
```

## 组合数学

### 排列与组合

> **排列**
> $$P\left(n, k\right) = \frac{n!}{\left(n - k\right)!}, 0 \le n, 0 \le k \le n$$
>
> 特殊的 $if ~ k = n ~ then$
> $$P\left(n, n\right) = n! = \prod_{i = 1}^{n} i, 1 \le n$$
>
> 当 $n$ 很大时可以根据 **斯特林公式**,$\pi$ 为圆周率，$e$ 为自然对数。
> $$n! \approx \sqrt{2 \pi n} \left(\frac{n}{e}\right)^{n}$$
>
> **组合**
> $$C\left(n, k\right) = C_{n}^{k} = \binom{n}{k} = \binom{n}{n-k} = \frac{P\left(n, k\right)}{P\left(k, k\right)} = \frac{n!}{\left(n - k!\right) k!}, 1 \le n, 0 \le k \le n$$

**多重集的排列问题**

1. 拆分原理：分步选位置

构造满足条件的序列，可拆解为$N$步选择“元素$i$的位置”，每步的选法对应一个组合数：

- **第1步**：从$T$个位置中选$C_1$个放元素$1$，选法数为$\binom{T}{C_1}$（组合数，含义是“从$T$个中选$C_1$个的方案数”）;
- **第2步**：从剩余$T - C_1$个位置中选$C_2$个放元素$2$，选法数为$\binom{T - C_1}{C_2}$；
- **第3步**：从剩余$T - C_1 - C_2$个位置中选$C_3$个放元素$3$，选法数为$\binom{T - C_1 - C_2}{C_3}$；
- ...
- **第$N$步**：剩余$C_N$个位置全放元素$N$，选法数为$\binom{C_N}{C_N} = 1$。

2. 乘积化简：等价于多项式系数

将每步的选法数相乘，化简后恰好等于多项式系数：
<div>
$$
\begin{align*}
&\binom{T}{C_1} \times \binom{T - C_1}{C_2} \times \binom{T - C_1 - C_2}{C_3} \times \dots \times \binom{C_N}{C_N} \\
=& \frac{T!}{C_1! \cdot (T - C_1)!} \times \frac{(T - C_1)!}{C_2! \cdot (T - C_1 - C_2)!} \times \dots \times \frac{C_N!}{C_N! \cdot 0!} \\
=& \frac{T!}{C_1! \cdot C_2! \cdot \dots \cdot C_N!}
\end{align*}
$$
</div>
（中间项$(T - C_1)!$、$(T - C_1 - C_2)!$等相互抵消，最终得到多项式系数）。


故，如果 $n$ 个元素中有部分元素重复，将 $n$ 元素进行全排列能够得到的不同排列方式总数为
$$\binom{n}{m_{1}, m_{2}, \cdots m_{k}} = \frac{n!}{m_{1} m_{2}! \cdots m_{k}!}, m_{1} + m_{2} + \cdots + m_{k} = n$$

$m_{i}$ 表示第 $i$ 个不同元素的重复次数。

例如，将字符串"$aabdeef$"进行全排列，能够得到的不同字符串排列种数为
$$P = \frac{7!}{2! \cdot 1! \cdot 1! \cdot 2! \cdot 1!} = 1260$$


为了便于计算组合数，还可以使用一下递推公式
$$C(n, k) = C(n - 1, k) + C(n - 1, k - 1)$$

```c++
long long Cnk[41][41] = {0};
for(int i = 0; i <= 40; i ++){
    Cnk[i][0] = Cnk[i][i] = 1;
    for(int j = 1; j < i; j ++){
        Cnk[i][j] = Cnk[i - 1][j] + Cnk[i - 1][j - 1];
    }
}
```

**注：** 因为阶乘增长得很快，在某些情况下，虽然给定组合数的最终结果在 $64$ 位整数的表示范围内，但直接按照定义计算，*中间结果*会超出 $64$ 整数的表示范围，此时需要采用一些特殊的技巧。

- 将阶乘的各个数进行素因子分解，消去分子和分母共同的**素因子**使中间数值变小。
- 计算式中分子各个乘数和分母各个乘数间的**最大公约数**来使中间结果变小。

### 康托展开和康托逆展开

> 给定一个长度为 $n\left(n \ge 1\right)$ 的字符串，其字符两两不同，如果将字符串的全排列按字典序排列，然后从 $1$ 开始为每个排列赋予一个序号，则可以将字符串的全排列映射到 $1 \sim n!$ 的正整数。

如果确定该字符串的全排列中指定序号所对应的排列呢？

可以证明，从 $0$ 到 $n! - 1$ 之间的任何整数 $m$，可以唯一地将其表示成一下形式(***康托展开***)：
$$m = a_{n - 1} \times \left(n - 1\right)! + a_{n - 2}! + \cdots + a_{2} \times 2! + a_{1} \times 1!$$

其中，$a_{i} \in \mathbb{Z}_{0}^{+},0 \le a_{i} \le i, i = 1, 2, \cdots, n - 1$。
例如：$23 = 3 \times 3! + 2 \times 2! + 1 \times 1!, n = 4$

> **注：**
> $$m = a_{n - 1} \left(n - 1\right)! + a_{n - 2} \left(n - 2\right)! + \cdots + a_{2} \times 2! + a_{1} times 1!$$
>
> 两边同除以 $\left(n - 1\right)!$
> $$\frac{m}{\left(n - 1\right)!} = a_{n - 1} + $$

### 隔板法

> 给定一个黑盒，黑盒中有 红、绿、蓝 等 $n$ 种颜色的球若干个。若已知有 $m$ 个球，那么总共有多少种可能得组合？
> 如果用向量 $\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 来定 义球的可能组合，其中 $x_{i}$ 代表第 $i$ 种颜色的球的数量，且 $\sum_{1}^{n} x_{i} = m$，那么可能得组合个数就为 $\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 的个数。

将 $m$ 个 $1$ 排列成一排，则 $m$ 个 $1$ 之间有 $m-1$ 个“空隙”，在这 $m-1$ 个空隙中任意选出 $n - 1$ 个空隙放入一个假想的“隔板”，则会将这 $m$ 个 $1$ 分隔成 $n$ 个互不相连的部分，划分后的结果恰好对应满足 $\sum_{1}^{n} x_{i} = m$，其中 $x_{i}$ 代表被“隔板”分隔后的第 $i$ 部分中 $1$ 的个数，也对应了第 $i$ 中颜色球的个数。 
 


### 第二类斯特林数

> **题目描述**
> Hz 刚刚学完排列组合，他忍不住开始思考一个很简单的问题：
> 如果将 $n$ 个不同的小球放入到 $m$ 个不同的盒子中，而且保证每个盒子都不为空，合法的分配方案有多少种呢？
> 现在请你回答这个问题，由于结果可能会很大，请你将结果 $mod$ $998244353998244353$ 后输出。  
> **输入描述**:
> 第一行给定两个整数 $n$，$m$ ($1≤n,m≤5000$)($1≤n,m≤5000$)，其含义如题面所述。  
> **输出描述**:
> 输出一个整数，表示合法方案数。
>
> **示例1**
> > **输入**
> > 3 2
> > **输出**
> > 6
>
> **示例2**
> > **输入**
> > 1000 1001
> > **输出**
> > 0

```c++
# include <bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define endl '\n'
#define pii pair<int, int>

const int MOD = 9'9824'4353;

void solve(){
    int n, m;
    cin >> n >> m;
    // 定义 dp[i][j] 表示将 i 个球，放入 j 个盒子的合法方案数
    vector<vector<int> > dp(n + 1, vector<int> (m + 1, 0));
    dp[0][0] = 1;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j ++){
            // 对于每个新球，可以选择放入已有的箱子中 dp[i - 1][j] * j (已放球的方案数*j个箱子可以放)；也可以放一个新的箱子重 dp[i - 1][j - 1] * j (已放球的方案数*j个新箱子可以选择)
            dp[i][j] = (dp[i - 1][j] % MOD + dp[i - 1][j - 1] % MOD) * j % MOD;
        }
    }    
    cout << dp[n][m] << endl;
}

signed main(void){
    ios::sync_with_stdio(0);
    //cin.tie(0); cout.tie(0);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

## 排列
### 循环分解

#### 定义

**排列的循环分解**是将一个排列($1 \sim N$ 的不重复序列)拆解为若干个不相交的循环的过程。每个元素属于且仅属于一个循环，循环内的元素沿着“位置->该位置的值->该值对应的位置”的路径最终回到起点，形成闭环。
- *排列*: 长度为 $N$ 的序列 $P = (P_1, P_2, \cdots, P_N)$，其中每个数是 $1 \sim N$ 的唯一值。
- *循环*: 对排列中的元素 $x$，沿着路径 $x \to P\left[x\right] \to P\left[P[x]\right] \to \cdots \to x$ 的遍历，最终回到起点，这条路径就是一个循环(也叫轮换)。 

**单循环**: 例如 $N = 3, P = \left[2, 3, 1\right]$ 可以分解为一个循环 (1, 2, 3)。
**双循环**: 例如 $N = 4, P = \left[2, 1, 4, 3\right]$ 可以分解为两个循环 (1, 2) (3, 4)。
**含自环**: 例如 $N = 3, P = \left[1, 3, 2\right]$ 可以分解为两个循环 (1) (2, 3)。

#### 性质

1. **不相交性**: 任意两个循环没有公共元素(每个元素属于且仅属于一个循环)。
2. **覆盖性**: 所有循环的元素集合恰好是排列的全部元素($1 \sim N$)。
3. **循环的长度和 = 排列长度 $N$
	设循环分解为 $C_{1}, C_{2}, \cdots, C_{m}$，每个循环 $C_{i}$ 的长度为 $L_{i}$，则 $\sum_{i = 1}^{m} L_{i}= N$。
4. **循环分解的唯一性(不考虑顺序和起始点)**
5. **最小交换次数 $= ~ N ~ -$ 循环个数 $m$。**
	排列还原为升序($1,2,3,\cdots,N$)的最小交换次数，等于 “元素总数 $N$” 减去 “循环的个数 $m$”。
	- *原理*: 长度为 $L$ 的循环，需要 $L - 1$ 次交换才能将其所有的元素归位。
	- *总交换次数* = $\sum_{i = 1}^{m} (L - 1)$ = $\sum_{i = 1}^{m} L - m$ = $N - m$。
	- **公式:** $K = N - m$($K$ 为最小交换次数)。
6. **交换对循环有影响。**
	交换排列中的两个元素 $i$ 和 $j$ $(i \lt 1)$，会改变循环分解的结构。
	- $i$ 和 $j$ 属于*同一个循环*(设原循环长度为 $L$)
		- *结果*: 原循环循环被拆解为两个循环，循环个数 $m$ 增加 $1$ ($m' = m + 1$)。
		- *最小交换次数变化:* $K' = N - m' = N - m - 1 = K - 1$。
	- $i$ 和 $j$ 属于*不同循环*(设两个循环长度为 $L_1$ 和 $L_2$)
		- *结果*: 两个循环合并为一个循环，循环个数 $m$ 减少 $1$ ($m' = m - 1$)。
		- *最小交换次数变化:* $K' = N - m' = N - m + 1 = K + 1$。
7. **循环的逆排列性质**
	循环 $P$ 的逆排列 $P^{-1}$ (满足 $P[P^{-1}[x]] = x$)的循环分解，与 $P$ 的循环分解结构相同，只是每个循环的方向相反。
	*意义*: 逆排列的最小交换次数与原排列相同(即循环个数 $m$ 不变)。

## 数学期望


# 几何

## 极角排序

```c++
template <typename T>
struct point{
    T x, y;
    point() : x(0), y(0){}
    point(T _x, T _y) : x(_x), y(_y){}
    // 叉乘
    T cross(const point<T> &b)const{
        return x * b.y - y * b.x;
    }
    T cross(const point<T> &a, const point<T> &b){
        return a.x * b.y - a.y * b.x;                                                    
    }
    // 逆时针
    bool operator<(const point<T> &nxt)const{
        // 是否在 x 轴上方
        bool a = y > 0 || y == 0 && x > 0;
        bool b = nxt.y > 0 || nxt.y == 0 && nxt.x > 0;
        if(a ^ b) return a; // 不同区域
        return cross(nxt) > 0;
    }
    // 到达 点o 的距离的平方 
    T dist2(const point<T> &o)const{
        return (x - o.x) * (x - o.x) + (y - o.y) * (y - o.y);
    }
};
```

# 格雷码

> 对于长度为 $2^{n}$ 的格雷码序列(包含 $0, 1, \cdots, 2^{n} - 1$ 所有的整数)，*任意相邻两个数的二进制表示仅 $1$ 位不同*，$且序列第一个和最后一个数的二进制也仅 $1$ 位不同。 

## 公式

$$gray(i) = i \oplus (i >> 1) $$
## 应用

- 构造 $0 \sim 2^{n} - 1$ 的排列，使相邻异或和最小。